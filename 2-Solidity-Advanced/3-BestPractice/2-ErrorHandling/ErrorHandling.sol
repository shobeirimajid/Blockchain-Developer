/**
    https://docs.soliditylang.org/en/v0.8.18/control-structures.html#error-handling-assert-require-revert-and-exceptions

    Error handling: 
        -Assert
        -Require
        -Revert
        -TryCatch
        

    Solidity uses "state-reverting" exceptions to handle "errors". 
    
        Such an exception "undoes all changes" made to the state in the current call (and all its sub-calls) and flags an "error" to the caller.

        When "exceptions" happen in a sub-call, they “bubble up” (exceptions are rethrown) automatically 
            unless they are caught in a "try/catch" statement. 

        Exceptions to this rule are 
                -send
                    and "low-level functions" 
                -call
                -delegatecall 
                -staticcall
        they return false as their first return value in case of an exception instead of “bubbling up”


    Warning:

        The low-level functions (call, delegatecall and staticcall) 
            return "true" as "their first return value" if the account called is "non-existent", as part of the design of the EVM. 
            
        "Account existence" must be checked prior to calling if needed.

        
    "Exceptions" can contain "error data" that is passed back to the "caller" in the form of "error" instances. 
    

    The built-in errors "Error" and "Panic" are used by special functions, as explained below. 

        -Error is used for “regular” error conditions 
            Error(string)

        -Panic is used for errors that should not be present in bug-free code.
            Panic(uint256)

        
    ---------------------------------
    Panic via assert 
    ---------------------------------

        The convenience functions "assert" and "require" can be used to check for conditions and throw an exception if the condition is not met.

        The "assert" function creates an "error" of type Panic(uint256). 
        The same error is created by the compiler in certain situations as listed below.

        Assert should only be used to "test" for "internal errors", and to "check invariants". 
        Properly functioning code should never create a Panic, not even on invalid external input. 
        If this happens, then there is a bug in your contract which you should fix. 
        Language analysis tools can evaluate your contract to identify the conditions and function calls which will cause a Panic.

        A Panic exception is generated in the following situations. 
        The "error code" supplied with the "error data" indicates the "kind of panic".


        0x00: Used for generic compiler inserted panics.
        0x01: If you call assert with an argument that evaluates to false.
        0x11: If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.
        0x12; If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).
        0x21: If you convert a value that is too big or negative into an enum type.
        0x22: If you access a storage byte array that is incorrectly encoded.
        0x31: If you call .pop() on an empty array.
        0x32: If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).
        0x41: If you allocate too much memory or create an array that is too large.
        0x51: If you call a zero-initialized variable of internal function type.


        The "require" function either creates an error without any data or an error of type Error(string). 
        It should be used to ensure valid conditions that cannot be detected until execution time. 
        This includes conditions on inputs or return values from calls to external contracts.

        Note:
            It is currently not possible to use "custom errors" in combination with "require".
            instead you can use :

                if (!condition) 
                    revert CustomError();

        
        An Error(string) exception (or an exception without data) is generated by the compiler in the following situations:

            1.Calling require(x) where x evaluates to false.

            2.If you use revert() or revert("description").

            3.If you perform an "external function call" targeting a contract that "contains no code".

            4.If your contract "receives Ether" via a public function "without payable" modifier
                including the 'constructor' and the 'fallback function'

            5.If your contract "receives Ether" via a "public getter function".


        For the following cases, the "error data" from the external call (if provided) is forwarded. 
        This means that it can either cause an "Error" or a "Panic" (or whatever else was given):

            1.If a .transfer() fails.

            2.If you "call a function" via a "message call" but it does not finish properly
                    * it runs 'out of gas'
                    * has no matching function
                    * throws an exception itself
              except when a "low level operation" call, send, delegatecall, callcode or staticcall is used. 
              The "low level" operations "never throw exceptions" but indicate failures by "returning false".

            3.If you create a contract using the new keyword but the contract creation does not finish properly.


        You can optionally provide a "message string" for "require", but not for "assert"


        Note:
        If you do not provide a "string argument" to "require", 
        it will revert with "empty error data", not even including the "error selector"


        The following example shows how you can use require to check conditions on inputs and assert for internal error checking.
*/


// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.5.0 <0.9.0;

contract Sharer {

    function sendHalf(address payable addr) public payable returns (uint balance) {

        require(msg.value % 2 == 0, "Even value required.");

        uint balanceBeforeTransfer = address(this).balance;

        addr.transfer(msg.value / 2);

        // Since 'transfer' throws an exception on 'failure' and can not 'call back' here,
        // there should be no way for us to still have half of the money.
        assert(address(this).balance == balanceBeforeTransfer - msg.value / 2);

        return address(this).balance;
    }
}



/**
    Internally, Solidity performs a "revert" operation (instruction 0xfd). 

    This causes the EVM to revert "all changes" made to the "state".

    The reason for reverting is that there is "no safe way to continue execution", because an "expected effect" did not occur. 

    Because we want to keep the "atomicity of transactions", the safest action is to "revert all changes" 
        and make the "whole transaction" (or at least call) without effect.

    In both cases, 
        the "caller" can react on such failures using "try/catch",  but
        the "changes in the callee will always be reverted"


    Note:

    before Solidity 0.8.0

        "Panic exceptions" used to "use the invalid opcode" , 
            which consumed "all gas" available to the call. 

        Exceptions that use "require" used to consume "all gas" until before the Metropolis release.


    revert:

        A "direct revert" can be triggered using the "revert statement" and the "revert function".

        The "revert statement" takes a "custom error" as direct argument without parentheses:

            revert CustomError(arg1, arg2);

        For backwards-compatibility reasons, there is also the revert() function, which uses parentheses and accepts a string:

            revert();
            revert(“description”);


        The "error data" will be passed back to the "caller" and can be caught there. 

        - revert()                  ---     causes a revert "without" any "error data"
        - revert("description")     ----    create an Error(string) error.
   

        Using a "custom error instance" will usually be "much cheaper" than a "string description", 
            because you can use the "name of the error" to describe it, which is encoded in only "four bytes". 
            A "longer description" can be supplied via NatSpec which does not incur any costs.
*/



/// The following example shows how to use an 
/// "error string" 
/// "custom error" 
/// together with "revert" and the equivalent "require":


pragma solidity ^0.8.4;

contract VendingMachine {

    address owner;
    error Unauthorized();

    function buy(uint amount) public payable {

        if (amount > msg.value / 2 ether)
            revert("Not enough Ether provided.");

        // Alternative way to do it:
        require(amount <= msg.value / 2 ether, "Not enough Ether provided.");

        // TODO: Perform the purchase.
    }

    function withdraw() public {

        if (msg.sender != owner)
            revert Unauthorized();

        payable(msg.sender).transfer(address(this).balance);
    }
}




/**
    The two ways 

        if (!condition) revert(...); 

        require(condition, ...); 
        
    are equivalent as long as the arguments to revert and require do not have side-effects, for example if they are just strings.



    Note:
    
        The "require" function is evaluated just as any other function.

        This means that all arguments are evaluated before the function itself is executed. 

        Ex:
            require(condition, f()) 
                
            the 'f()' is executed even IF the 'condition' is true.



    The provided string is 'abi-encoded' as if it were a call to a function Error(string). 
    

    In the above example, 

        revert("Not enough Ether provided."); 

    returns the following 'hexadecimal' as 'error return data':

        0x08c379a0                                                         // Function selector for Error(string)
        0x0000000000000000000000000000000000000000000000000000000000000020 // Data offset
        0x000000000000000000000000000000000000000000000000000000000000001a // String length
        0x4e6f7420656e6f7567682045746865722070726f76696465642e000000000000 // String data


    The 'provided message' can be 'retrieved' by the 'caller' using try/catch as shown below.


    Note:
    There used to be a keyword called 'throw' with the same semantics as 'revert()' which
        was deprecated in version 0.4.13 
        and removed in version 0.5.0
*/



pragma solidity >=0.8.1;

interface DataFeed { function getData(address token) external returns (uint value); }

contract FeedConsumer {
    DataFeed feed;
    uint errorCount;
    function rate(address token) public returns (uint value, bool success) {
        // Permanently disable the mechanism if there are
        // more than 10 errors.
        require(errorCount < 10);
        try feed.getData(token) returns (uint v) {
            return (v, true);
        } catch Error(string memory /*reason*/) {
            // This is executed in case
            // revert was called inside getData
            // and a reason string was provided.
            errorCount++;
            return (0, false);
        } catch Panic(uint /*errorCode*/) {
            // This is executed in case of a panic,
            // i.e. a serious error like division by zero
            // or overflow. The error code can be used
            // to determine the kind of error.
            errorCount++;
            return (0, false);
        } catch (bytes memory /*lowLevelData*/) {
            // This is executed in case revert() was used.
            errorCount++;
            return (0, false);
        }
    }
}



/**

    The 'try' keyword has to be followed by an expression representing an 'external function call' or a 'contract creation' (new ContractName()). 
    'Errors inside the expression' are not caught 

    for example if it is a complex expression that also involves internal function calls, any Error will not be caught
        only a 'revert' happening inside the 'external call' itself. 
    
    The 'returns part' (which is optional), return variables matching the 'types returned by the external call'. 

        In case there was no error, 
        these variables are assigned and the contract’s execution continues inside the first success block. 
        
        If the end of the 'success block' is reached, execution continues after the 'catch blocks'.

    

    Solidity supports different kinds of catch blocks depending on the type of error:


        1. catch Error(string memory reason) { ... }
        
            will be executed if the error was caused by : 
                1.revert("reasonString")
                2.require(false, "reasonString")
                3.or an internal error that causes such an exception


        2. catch Panic(uint errorCode) { ... }
        
            will be run If the error was caused by :
                1.panic, i.e. by a failing assert
                2.division by zero
                3.invalid array access
                4.arithmetic overflow and ...
                

        3. catch (bytes memory lowLevel_ErrorData) { ... }
        
            will be executed if 
                1.the error signature does not match any other clause, 
                2.if there was an error while decoding the error message, 
                3.if no error data was provided with the exception. 


        4. catch { ... }
        
            If you are not interested in the error data, you can just use catch { ... } (even as the only catch clause) instead of the previous clause.


    It is planned to support other types of "error data" in the future. 
    The "strings Error" and "Panic" are currently parsed as is and are "not treated as identifiers".

    In order to "catch all error cases", you have to have at least the clause catch { ...} or the clause catch (bytes memory lowLevelData) { ... }.

    The variables declared in the returns and the catch clause are only in scope in the" block that follows".


    Note

    If an error happens during the decoding of the return data inside a try/catch-statement, 
        this causes an exception in the currently executing contract and because of that, 
        it is not caught in the catch clause. 
        If there is an error during decoding of catch Error(string memory reason) 
            and there is a low-level catch clause, 
            this error is caught there.

    
    Note

    If execution reaches a catch-block, 
        then the state-changing effects of the external call have been reverted. 

    If execution reaches the success block, 
        the effects were not reverted. 

    If the effects have been reverted, 
        then execution either continues in a catch block 
        or the execution of the try/catch statement itself reverts 
        (for example due to decoding failures as noted above or due to not providing a low-level catch clause).

    
    Note

    The reason behind a 'failed call' can be manifold. 
        
        Do not assume that the 'error message' is coming directly from the 'called contract': 
            The error might have happened deeper down in the 'call chain' and the called contract just forwarded it. 

        Also, it could be due to an 'out-of-gas' situation and not a 'deliberate error condition': 

            The caller always retains at least 1/64th of the gas in a call and thus:
                even if the called contract goes out of gas, the caller still has some gas left.


*/
