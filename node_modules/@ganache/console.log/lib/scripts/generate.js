"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const path_1 = require("path");
const helpers_1 = require("./helpers");
const handlers_1 = require("../src/handlers");
const handlersKeys = Object.keys(handlers_1.Handlers);
const solidityFunctions = [];
const javascriptSignatures = [];
const appendToSignatures = (signature) => {
    if (signature.javascript &&
        !javascriptSignatures.includes(signature.javascript)) {
        javascriptSignatures.push(signature.javascript);
    }
    if (signature.solidity) {
        if (solidityFunctions.includes(signature.solidity)) {
            // this shouldn't happen
            throw new Error("duplicate solidity function signature created");
        }
        solidityFunctions.push(signature.solidity);
    }
};
for (const signature of (0, helpers_1.getSignatures)())
    appendToSignatures(signature);
const signatureFile = `/*
 * This file was automatically generated by \`./src/chains/ethereum/console.log/scripts/generate.ts\`; do not edit. */

import { ${handlersKeys.join(", ")}, fixedBytes } from "./handlers";

export const signatureMap = new Map([
${javascriptSignatures.join(",\n\n")}
]);
`;
const solidityFile = `// SPDX-License-Identifier: MIT
pragma solidity >= 0.4.22 <0.9.0;

library console {
    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);

    function _sendLogPayload(bytes memory payload) private view {
        address consoleAddress = CONSOLE_ADDRESS;
        assembly {
            let argumentsLength := mload(payload)
            let argumentsOffset := add(payload, 32)
            pop(staticcall(gas(), consoleAddress, argumentsOffset, argumentsLength, 0, 0))
        }
    }
${solidityFunctions.join("\n")}
}`;
(0, fs_1.writeFileSync)((0, path_1.join)(__dirname, "../src/", "signatures.ts"), signatureFile);
(0, fs_1.writeFileSync)((0, path_1.join)(__dirname, "../", "console.sol"), solidityFile);
//# sourceMappingURL=generate.js.map